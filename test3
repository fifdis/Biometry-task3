import numpy as np
import cv2
import os
import matplotlib.pyplot as plt
from sklearn.model_selection import train_test_split
from sklearn.neighbors import KNeighborsClassifier
from sklearn.metrics import accuracy_score


# Функция для загрузки базы ORLfaces
def load_ORL_faces(data_folder):
    images = []
    labels = []
    for i in range(1, 41):
        for j in range(1, 11):
            img_path = os.path.join(data_folder, f"s{i}", f"{j}.pgm")
            img = cv2.imread(img_path, cv2.IMREAD_GRAYSCALE)
            if img is not None:  # Проверяем, удалось ли загрузить изображение
                images.append(img.flatten())
                labels.append(i)
    return np.array(images), np.array(labels)


# Функция для реализации метода PCA с уменьшением размерности изображения
def pca_image_reduction(X, num_components):
    # Центрирование данных
    X_mean = np.mean(X, axis=0)
    X_centered = X - X_mean

    # Вычисление ковариационной матрицы
    cov_matrix = np.cov(X_centered.T)

    # Вычисление собственных значений и собственных векторов
    eigenvalues, eigenvectors = np.linalg.eigh(cov_matrix)

    # Сортировка собственных значений и векторов по убыванию
    sorted_indices = np.argsort(eigenvalues)[::-1]
    sorted_eigenvalues = eigenvalues[sorted_indices]
    sorted_eigenvectors = eigenvectors[:, sorted_indices]

    # Преобразование данных
    transformed_data = np.dot(X_centered, sorted_eigenvectors[:, :num_components])

    return sorted_eigenvalues, sorted_eigenvectors[:, :10]


# Функция для реализации метода PCA с использованием матрицы Грама-Шмидта
def pca_gram_schmidt(X, num_components):
    # Центрирование данных
    X_mean = np.mean(X, axis=0)
    X_centered = X - X_mean

    # Вычисление матрицы Грама
    gram_matrix = np.dot(X_centered, X_centered.T)

    # Применение метода Грама-Шмидта
    q, _ = np.linalg.qr(gram_matrix)

    # Вычисление собственных значений и собственных векторов
    eigenvalues, eigenvectors = np.linalg.eigh(q)

    # Сортировка собственных значений и векторов по убыванию
    sorted_indices = np.argsort(eigenvalues)[::-1]
    sorted_eigenvalues = eigenvalues[sorted_indices]
    sorted_eigenvectors = eigenvectors[:, sorted_indices]

    # Преобразование данных
    transformed_data = np.dot(X_centered.T, sorted_eigenvectors[:, :num_components])

    return sorted_eigenvalues, sorted_eigenvectors[:, :10]


# Каскадный метод PCA
def pca_cascade(X, num_components):
    # Применение сначала PCA с использованием метода Грама-Шмидта,
    # а затем PCA с уменьшением размерности изображения
    eigenvalues_gram, eigenvectors_gram = pca_gram_schmidt(X, num_components)
    transformed_data, _ = pca_image_reduction(X, num_components)

    return eigenvalues_gram, eigenvectors_gram, transformed_data


# Параллельный метод PCA
def pca_parallel(X, num_components):
    # Применение PCA с использованием метода Грама-Шмидта и уменьшением размерности параллельно
    eigenvalues_gram, eigenvectors_gram = pca_gram_schmidt(X, num_components)
    X_centered = X - np.mean(X, axis=0)
    transformed_data = np.dot(X_centered, eigenvectors_gram[:, :num_components])

    return eigenvalues_gram, eigenvectors_gram[:, :10], transformed_data


# Функция для оценки точности распознавания
def evaluate_accuracy(X_train, y_train, X_test, y_test, num_neighbors=1):
    X_train = X_train.reshape(-1, 1)
    X_test = X_test.reshape(-1, 1)
    knn = KNeighborsClassifier(n_neighbors=num_neighbors)
    knn.fit(X_train, y_train)
    y_pred = knn.predict(X_test)
    accuracy = accuracy_score(y_test, y_pred)
    return accuracy


# Загрузка данных ORLfaces
data_folder = "ORLdataset"
images, labels = load_ORL_faces(data_folder)

# Количество компонент для PCA
num_components = 100

# Разделение данных на обучающий и тестовый наборы
X_train, X_test, y_train, y_test = train_test_split(images, labels, test_size=0.3, random_state=42)

# Список числа тестовых изображений для анализа
test_sizes = [10, 20, 30, 40, 50]

# Массивы для сохранения результатов
accuracy_cascade = []
accuracy_parallel = []

# Проход по каждому числу тестовых изображений
for size in test_sizes:
    # Оценка точности для каскадного метода PCA
    eigenvalues_gram, eigenvectors_gram, transformed_data_cascade = pca_cascade(X_train, num_components)
    accuracy_cascade.append(evaluate_accuracy(transformed_data_cascade[:size], y_train[:size], X_test, y_test))

    # Оценка точности для параллельного метода PCA
    eigenvalues_gram, eigenvectors_gram, transformed_data_parallel = pca_parallel(X_train, num_components)
    accuracy_parallel.append(evaluate_accuracy(transformed_data_parallel[:size], y_train[:size], X_test, y_test))

# Визуализация результатов
plt.figure(figsize=(10, 5))

plt.plot(test_sizes, accuracy_cascade, label='Cascade PCA')
plt.plot(test_sizes, accuracy_parallel, label='Parallel PCA')

plt.xlabel('Number of Test Images')
plt.ylabel('Accuracy')
plt.title('Accuracy vs. Number of Test Images')
plt.legend()
plt.grid(True)
plt.show()

